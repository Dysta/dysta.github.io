[{"content":"Bonjour à tous ! Pour ce second post sur mon blog, je vais vous parler de mon nouveau blog ! Propulsé par Hugo !\n","permalink":"https://dysta.github.io/posts/nouveau-blog/","summary":"Bonjour à tous ! Pour ce second post sur mon blog, je vais vous parler de mon nouveau blog ! Propulsé par Hugo !","title":"Un nouveau blog pour une nouvelle vie"},{"content":"Bonjour à tous ! Pour ce premier post sur mon blog j\u0026rsquo;aimerais vous partager un petit bout de code que j\u0026rsquo;avais fais il y a un moment.\nCertains d\u0026rsquo;entre-vous l\u0026rsquo;ont utilisés, mais pas tous. Il est également inclus dans mon CMS privé afin de récupérer des statistiques sur RPG.\nCe petit bout de code permet de parser une page RPG afin de récupérer ses infos comme :\nvaleur out le nom le nombre de vote la position le graphe RPG Voici le code de ce petit script, écrit en PHP mais facilement transcriptable dans d\u0026rsquo;autre langage :\n\u0026lt;?php /** * API pour RPG paradize * @author Dysta */ class RpgApi { /** * HTML code * @var string */ private $webContent; /** * RPG id * @var int */ private $id; /** * RPG position * @var int */ private $position; /** * RPG name * @var string */ private $name; /** * RPG outs * @var int */ private $outs; /** * RPG votes * @var int */ private $votes; /** * RPG urls * @var array */ private $urls; /** * RPG graph data * @var array */ private $graph; private function getWebContent() { $opts = array( CURLOPT_URL =\u0026gt; \u0026#39;http://rpg-paradize.com/site--\u0026#39; . $this-\u0026gt;id, CURLOPT_HEADER =\u0026gt; true, CURLOPT_RETURNTRANSFER =\u0026gt; true, CURLOPT_CONNECTTIMEOUT =\u0026gt; 3, CURLOPT_USERAGENT =\u0026gt; \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36 Edge/12.246\u0026#39; ); $ch = curl_init(); curl_setopt_array($ch, $opts); $this-\u0026gt;webContent = curl_exec($ch); curl_close($ch); } private function parseName() { preg_match(\u0026#39;/\u0026lt;b\u0026gt;(.*?)\u0026lt;\\/b\u0026gt;/\u0026#39;, $this-\u0026gt;webContent, $name); $this-\u0026gt;name = $name[1]; } private function parseVote() { preg_match(\u0026#39;/Vote : (.*?)\u0026lt;\\/a\u0026gt;/\u0026#39;, $this-\u0026gt;webContent, $vote); $this-\u0026gt;votes = $vote[1]; } private function parsePosition() { preg_match(\u0026#39;/Position (.*?)\u0026lt;\\/b\u0026gt;/\u0026#39;, $this-\u0026gt;webContent, $position); $this-\u0026gt;position = $position[1]; } private function parseOut() { preg_match(\u0026#39;/Clic Sortant : (.*?)\u0026lt;\\/div\u0026gt;/\u0026#39;, $this-\u0026gt;webContent, $out); $this-\u0026gt;outs = $out[1]; } private function parseUrls() { $this-\u0026gt;urls[\u0026#39;out\u0026#39;] = \u0026#34;https://www.rpg-paradize.com/out.php?num=\u0026#34; . $this-\u0026gt;id; preg_match(\u0026#39;/hidden;\\\u0026#34;\u0026gt;http(s)?:\\/\\/(.*?)\u0026lt;\\/a\u0026gt;/\u0026#39;, $this-\u0026gt;webContent, $urls); $this-\u0026gt;urls[\u0026#39;real\u0026#39;] = substr(explode(\u0026#34;\u0026gt;\u0026#34;, $urls[0])[1], 0, -3); } private function parseGraph() { preg_match(\u0026#39;/labels : \\[(.*?)\\]/\u0026#39;,$this-\u0026gt;webContent, $label); preg_match(\u0026#39;/data : \\[(.*?)\\]/\u0026#39;, $this-\u0026gt;webContent, $data); $array_label = explode(\u0026#34;,\u0026#34;, $label[1]); $array_data = explode(\u0026#34;,\u0026#34;, $data[1]); foreach($array_label as $k =\u0026gt; $v) $array_label[$k] = substr($v, 1, -1); $this-\u0026gt;graph = array(); foreach ($array_label as $k =\u0026gt; $v) { $this-\u0026gt;graph[$k][\u0026#39;date\u0026#39;] = $array_label[$k]; $this-\u0026gt;graph[$k][\u0026#39;vote\u0026#39;] = $array_data[$k]; } } /** * Init RpgApi * @param int $id id of the rpg page */ public function __construct($id) { $this-\u0026gt;id = $id; } /** * * Return RPG name * @return string name */ public function getName() { if (empty($this-\u0026gt;webContent)) $this-\u0026gt;getWebContent(); if (empty($this-\u0026gt;name)) $this-\u0026gt;parseName(); return $this-\u0026gt;name; } /** * Return RPG vote * @return int vote number */ public function getVote() { if (empty($this-\u0026gt;webContent)) $this-\u0026gt;getWebContent(); if (empty($this-\u0026gt;votes)) $this-\u0026gt;parseVote(); return $this-\u0026gt;votes; } /** * Return RPG position * @return int position number */ public function getPosition() { if (empty($this-\u0026gt;webContent)) $this-\u0026gt;getWebContent(); if (empty($this-\u0026gt;position)) $this-\u0026gt;parsePosition(); return $this-\u0026gt;position; } /** * Return RPG out * @return int out number */ public function getOut() { if (empty($this-\u0026gt;webContent)) $this-\u0026gt;getWebContent(); if (empty($this-\u0026gt;outs)) $this-\u0026gt;parseOut(); return $this-\u0026gt;outs; } /** * Return RPG url * @return array out url */ public function getUrls() { if (empty($this-\u0026gt;webContent)) $this-\u0026gt;getWebContent(); if (empty($this-\u0026gt;urls)) $this-\u0026gt;parseUrls(); return $this-\u0026gt;urls; } /** * Return RPG graph data * @return array RPG graph data as array(\u0026#39;date\u0026#39;, \u0026#39;votes\u0026#39;) */ public function getGraph() { if (empty($this-\u0026gt;webContent)) $this-\u0026gt;getWebContent(); if (empty($this-\u0026gt;graph)) $this-\u0026gt;parseGraph(); return $this-\u0026gt;graph; } /** * Return data as a JSON string * @return string the JSON string */ public function toJSON() { $data = $this-\u0026gt;toArray(); return json_encode($data); } /** * Return data as a Array object * @return array the array object */ public function toArray() { return array( \u0026#39;name\u0026#39; =\u0026gt; $this-\u0026gt;getName(), \u0026#39;vote\u0026#39; =\u0026gt; $this-\u0026gt;getVote(), \u0026#39;position\u0026#39; =\u0026gt; $this-\u0026gt;getPosition(), \u0026#39;out\u0026#39; =\u0026gt; $this-\u0026gt;getOut(), \u0026#39;urls\u0026#39; =\u0026gt; $this-\u0026gt;getUrls(), \u0026#39;graphe\u0026#39; =\u0026gt; $this-\u0026gt;getGraph() ); } } ?\u0026gt; Le format de sorti des infos est en json. Cela permet d\u0026rsquo;être facilement sérialisé à sa réception.\nLe graphe RPG Comme dit plus haut, ce petit script permet de récupérer le graphe RPG. Enfin.. il ne récupère pas le graphe en lui-même sinon ça serait beaucoup trop compliqué. Non ! Il récupère simplement les données servant à construire le graphe sur RPG.\nRPG Paradize utilise la bibliothèque Char.js pour générer ses graphes. Le fait de récupérer seulement les données nous permet à nous d\u0026rsquo;utiliser une autre bibliothèque de notre choix afin de reconstruire le graphe derrière, comme par exemple Morris.js (utilisé sur mon CMS privé).\nVoici, en exemple, la page d\u0026rsquo;administration de mon CMS qui reconstruit le graphe d\u0026rsquo;une page RPG : Et voici le graphe d\u0026rsquo;origine : On peut également voir que les données sont récupérés correctement en haut comme la position, le nombre de vote et les clics sortant.\nEn espérant que ce petit billet vous aura plu. Dans un prochain billet, je vous montrerais comment faire un système de vote par valeur out en utilisant l\u0026rsquo;API !\n","permalink":"https://dysta.github.io/posts/api-rpg-paradize/","summary":"Bonjour à tous ! Pour ce premier post sur mon blog j\u0026rsquo;aimerais vous partager un petit bout de code que j\u0026rsquo;avais fais il y a un moment.\nCertains d\u0026rsquo;entre-vous l\u0026rsquo;ont utilisés, mais pas tous. Il est également inclus dans mon CMS privé afin de récupérer des statistiques sur RPG.\nCe petit bout de code permet de parser une page RPG afin de récupérer ses infos comme :\nvaleur out le nom le nombre de vote la position le graphe RPG Voici le code de ce petit script, écrit en PHP mais facilement transcriptable dans d\u0026rsquo;autre langage :","title":"Une API pour RPG Paradize ?"},{"content":" ","permalink":"https://dysta.github.io/cv/","summary":"cv","title":"Curriculum Vitae"}]